# 불변 클래스
- 인스턴스의 내부 값을 수정할 수 없는 클래스
- 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다.
- 자바 플랫폼 라이브러리에는 다양한 불변 클래스가 있다.
  - String, 기본 타입의 래핑된 클래스들, BigInteger, BigDecimal

## 불변 클래스를 만드는 규칙
- 객체의 상태를 변경하는 메서드(setter)를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다.
  - final로 선언한다.
  - 모든 생성자를 private으로 만든 후 정적 팩토리 메서드를 사용한다.
    - `super()`를 호출할 수 없어 상속이 불가능하다.
- 모든 필드를 private final로 선언한다.
- 클라이언트에서 인스턴스 내에 가변 객체의 참조를 얻을 수 없게 해야한다.
  - Collection에 대한 getter를 제공하면 안 된다.
  - 생성자, 접근자(getter), readObject 메서드 모두에서 방어적 복사를 수행하라.

## 불변 객체를 써야 하는 이유
### 1. 스레드 안전
- 불변 객체는 근본적으로 thread-safe 하여 따로 동기화할 필요가 없다.
- 여러 스레드가 동시에 사용해도 절대 훼손되지 않는다.
- 따라서 **안심하고 공유할 수 있다.**
- 불변 클래스라면 한 번 만든 인스턴스를 최대한 재활용하는 것을 권한다.
  - ex) 상수(public static final), 캐싱(정팩메)
- 아무리 복사해봐야 원본과 똑같으니 방어적 복사가 필요없다.
  - 불변 클래스는 clone 메서드나 복사 생성자를 제공하지 않는 것이 좋다.

### 2. 내부 데이터 공유
- 불변 객체끼리는 내부 데이터를 공유할 수 있다.
```java
public class BigInteger extends Number implements Comparable<BigInteger> {
    final int signum;   // 값의 부호
    final int[] mag;    //값의 크기
    
    public BigInteger negate() {
        return new BigInteger(this.mag, -this.signum);
    }
}
```
- 위 코드는 BigInteger 클래스 내부의 코드이다.
  - `negate` 메서드는 크기가 같고 부호만 반대인 새로운 BigInteger을 생성한다.
  - 배열은 가변이지만 복사하지 않고 원본 인스턴스와 공유해도 된다.
  - 그 결과 `negate` 메서드를 통해 새로 만들어진 BigInteger 인스턴스도 원본 인스턴스가 가리키는 내부 배열을 그대로 가리킨다.

### 3. 구성요소로 사용
- 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.
  - 구조가 아무리 복잡하더라도 불변식을 유지하기 훨씬 수월하다.
  - ex) Set의 구성 요소나 Map의 key
    - Map이나 Set은 안에 담긴 값이 바뀌면 불변식이 허물어진다.(?)

### 4. 실패 원자성
- 불변 객체는 그 자체로 실패 원자성을 제공한다.
  - 실패 원자성이란 `호출된 메서드가 실패하더라도 해당 객체는 호출 전 상태를 유지해야 한다`는 성질이다.

## 단점
- 값이 다르면 반드시 독립된 객체로 만들어야 한다.
  - 값의 가짓수가 많으면 비용이 크다.
    - ex) BigInteger의 비트 하나를 바꾸는 경우
  - 원하는 객체를 완성하기까지의 단계가 많고, 그 중간 단계에서 만들어진 객체들이 모두 버려진다면 성능 문제가 더 불거진다.

## 해결방안
### 다단계 연산(multistep operation)
- 흔하게 쓰일 다단계 연산들을 기본 기능으로 미리 제공하는 방법이다.
  - 이를 가변 동반 클래스(companion class)라고 한다.
    - 대표적인 예로 String의 가변 동반 클래스인 StringBuilder가 있다.

## 정리
- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.
  - 값 객체(VO)는 항상 불변으로 만들자.
- 불변으로 만들 수 없는 클래스는 변경할 수 있는 부분을 최소한으로 줄이자.
- 합당한 이유가 없다면 모든 필드는 private final이어야 한다.
- 생성자는 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
  - 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안 된다.
  - 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안 된다.


